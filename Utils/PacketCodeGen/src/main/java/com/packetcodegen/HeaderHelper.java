/**
 * For copyright information see the LICENSE document.
 */

package com.packetcodegen;

import java.text.SimpleDateFormat;
import java.util.Calendar;

/**
 * Manages the header of an Action or a nested struct.
 * 
 * @author miracle444
 */
public final class HeaderHelper 
{
    
    private final String firstPart;     // contains the first part of the header code
    private final String secondPart;    // contains the second part of the header code
    private String imports;             // contains the imports code
    private boolean hasListImport;      // indicates whether it already has teh list import
    private boolean hasVectorImport;    // indicates whether it already has teh vector import
    
    
    /**
     * Constructor.
     * this constructor is used by ClassHelper objects.
     * 
     * @param   packet      the packet this header corresponds to
     */
    public HeaderHelper(PacketConverter packet)
    {
        this.firstPart =
                "/**\n" +
                " * For copyright information see the LICENSE document.\n" +
                " */\n" +
                "\n" +
                "/**\n" +
                " * Auto-generated by PacketCodeGen, on " + getDate() + "\n" +
                " */\n" +
                "\n" +
                "package " + packet.getPackageName() + ";\n" +
                "\n";
        
        this.imports =
                "import com.realityshard.shardlet.GenericAction;\n" +
                (packet.getFromClient() ? "import java.nio.BufferUnderflowException;\n" :
                                          "import java.nio.BufferOverflowException;\n") +
                "import java.nio.ByteBuffer;\n" +
                (packet.getFromClient() ? "" :"import java.nio.ByteOrder;\n");
        
        this.secondPart =                
                "\n" +
                "/**\n" + 
                " * This is an automatically generated ShardletAction.\n" +
                " * It resembles the packet template that has been \n" +
                " * parsed from our packet templates xml.\n" +
                " *\n" +
                packet.getDescription() +
                " *\n" +
                " * @author " + packet.getAuthor() + "\n" +
                " */\n" +
                "public final class " + packet.getActionName() + " extends GenericAction\n" +
                "{\n" +
                "\n";
    }

    
    /**
     * Constructor.
     * this constructor is used by nested structs. 
     * 
     * @param   indention       the number of spaces of an indentation.
     * @param   field           the nested struct field this header is corresponding to.
     */
    public HeaderHelper(final String indention, FieldConverter field)
    {
        this.firstPart = this.imports = "";
        
        this.secondPart =
                indention + "public final class " + field.getType() + "\n" +
                indention + "{\n" +
                indention + "\n";
    }
    
    
    /**
     * iteration routine to add fields to check for selective imports.
     * 
     * @param       field           the field that has to be added.
     */
    public void addField(final FieldConverter field)
    {
        if (field.isArray())
        {
            addListImport();
        }
        
        if (field.isVector())
        {
            addVectorImport();
        }
        
        if (field.isNested())
        {
            // to simplify the packetcodegen
            // we just add both imports if there is any nested struct
            // involved so we dont have to check through all fields of
            // all nested fields.
            addListImport();
            addVectorImport();
        }
    }
    
    
    /**
     * Helper function.
     * adds the list import and makes sure its only added once.
     */
    private void addListImport()
    {
        if (!hasListImport)
        {
            hasListImport = true;
            this.imports += "import java.util.List;\n";
        }
    }
    
    /**
     * Helper function.
     * adds the vector import and makes sure its only added once.
     */
    private void addVectorImport()
    {
        if (!hasVectorImport)
        {
            hasVectorImport = true;
            this.imports += "import java.util.Vector;\n";
        }
    }
    
    
    /**
     * Getter.
     * 
     * @return  the complete header managed by this class. 
     */
    @Override
    public String toString()
    {
        return this.firstPart + this.imports + this.secondPart;
    }
    

    /**
     * Helper function.
     * 
     * @return  the current date.
     */
    private String getDate()
    {
        return (new SimpleDateFormat("yyyy-MM-dd")).format(Calendar.getInstance().getTime());
    }
}
