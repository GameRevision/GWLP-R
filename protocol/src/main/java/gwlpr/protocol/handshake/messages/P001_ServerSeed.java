/**
 * For copyright information see the LICENSE document.
 */

package gwlpr.protocol.handshake.messages;

import static gwlpr.protocol.serialization.GWMessageSerializationRegistry.getFilter;
import static gwlpr.protocol.serialization.GWMessageSerializationRegistry.register;
import gwlpr.protocol.serialization.GWMessage;
import gwlpr.protocol.serialization.NettySerializationFilter;
import gwlpr.protocol.util.IsArray;
import io.netty.buffer.ByteBuf;


/**
 * Generated by hand :P
 *
 * STEP 3: OUTGOING SERVER SEED
 *
 * Special message: Includes header and length in the first two bytes statically.
 *
 * @author _rusty
 */
public class P001_ServerSeed
    extends GWMessage
{

    private short header = 1;
    private short length = (2 + 20);

    @IsArray(constant=true, size=20, prefixLength = -1)
    private byte[] encryptedRC4Key;


    static
    {
        register(P001_ServerSeed.class);
    }


    @Override
    public short getHeader()
    {
        return 1;
    }


    public void setEncryptedRC4Key(byte[] encryptedRC4Key)
    {
        this.encryptedRC4Key = encryptedRC4Key;
    }


    public void serializeInto(ByteBuf buffer)
    {
        NettySerializationFilter filter = getFilter(P001_ServerSeed.class);
        filter.serialize(buffer, this);
    }
}
